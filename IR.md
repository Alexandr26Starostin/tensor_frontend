# Спецификация промежуточного представления открытой нейросетевой сети обмена (ONNX IR)

**Назначение**

Этот документ содержит нормативную спецификацию семантики ONNX.

Файлы `.proto` и `.proto3`, находящиеся в папке [onnx](/onnx/), представляют собой нормативную спецификацию синтаксиса, написанную на языке определения [Protocol Buffers](https://developers.google.com/protocol-buffers). Комментарии в файлах `.proto` и `.proto3` предназначены для улучшения читаемости этих файлов, но не являются нормативными в случае конфликта с этим документом. О таких конфликтах следует сообщать как об ошибках документации.

**Примечания по валидации модели**

Доступен [инструмент](../onnx/checker.py) для выполнения общей валидации моделей на соответствие данной спецификации. Он реализован на C++ с оберткой командной строки на Python.

**Примечания по формулировкам в этом и всех связанных документах**:

1. Использование слов СЛЕДУЕТ, ДОЛЖЕН, МОЖЕТ и т.д. в этом документе соответствует [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

2. Использование термина 'список' обозначает упорядоченную коллекцию элементов, 'множество' — неупорядоченную коллекцию уникальных элементов, а 'набор' — неупорядоченную коллекцию элементов, которые могут быть неуникальными.

## Компоненты

ONNX — это открытая спецификация, состоящая из следующих компонентов:

1. Определение расширяемой модели вычислительного графа.

2. Определение стандартных типов данных.

3. Определение встроенных операторов.

Пункты #1 и #2 вместе составляют спецификацию промежуточного представления ONNX, или 'IR', которая рассматривается в данном документе; встроенные операторы описаны в документах, перечисленных в конце. В частности, встроенные операторы делятся на набор примитивных операторов и функций. Функция — это оператор, семантика которого формально выражается через развертывание в подграф (называемый телом функции) с использованием других операторов (и функций). С точки зрения функциональности, совместимый с ONNX фреймворк или среда выполнения могут встроить тело функции для ее выполнения, если у них нет соответствующей реализации оператора.

Существует два официальных варианта ONNX; основное различие между ними заключается в наборе операторов по умолчанию. **ONNX-ML** расширяет набор операторов **ONNX** алгоритмами машинного обучения, не основанными на нейронных сетях.

До версии IR 6 спецификация ONNX и формат модели касались только логического вывода (также известного как скоринг). Начиная с версии IR 7 спецификация ONNX и формат модели также поддерживают обучение. Обучающая модель ONNX является расширением модели для логического вывода. Среда выполнения, предназначенная только для логического вывода, может использовать обучающую модель, игнорируя расширения, связанные с обучением. Однако модель только для логического вывода может обеспечить представление, более оптимальное для целей логического вывода, чем обучающая модель.

## Агностичность среды выполнения

ONNX не предполагает и не подразумевает какого-либо конкретного метода реализации среды выполнения.

Например, реализация может состоять из расширенной среды выполнения, которая интерпретирует модель; это может быть генератор кода, который полностью транслирует модель в исполняемый код для некоторого целевого языка программирования; это может быть аппаратная реализация; это может быть комбинация двух или трех из вышеперечисленных вариантов.

Ничто в этой спецификации не должно истолковываться как поддержка одного подхода к реализации перед другим; любые комментарии о внутренней работе конкретных реализаций следует интерпретировать как примеры.

## Версионирование ONNX

Спецификация IR, отдельные модели и наборы операторов — все имеют версии. Кроме того, каждый отдельный оператор указывает, в какой версии содержащего его набора операторов он был представлен или стабилизирован.

Номера версий могут использоваться как простые числа или для кодирования [семантических версий](https://semver.org/) (также известных как SemVer). При использовании семантических версий соглашение заключается в использовании двух самых старших байтов для основного номера, следующих двух байтов для второстепенного номера и четырех младших байтов для номера патча/сборки/исправления ошибки. При использовании семантического версионирования по крайней мере один из основных/второстепенных номеров ДОЛЖЕН быть ненулевым.

Спецификация IR использует простые монотонно возрастающие числа для своих версий. Допустимые версии IR определены перечислением `onnx.Version` в [onnx.proto](/onnx/onnx.proto).

Наборы операторов используют простой номер версии. Каждая версия набора операторов представляет собой снимок набора операторов и их семантики на определенный момент времени.

Эта спецификация не дает указаний о том, какую схему версионирования следует использовать производителям моделей.

Более подробную информацию о соглашениях и лучших практиках версионирования IR, наборов операторов и моделей можно найти в [Версионировании](Versioning.md).

## Расширяемая модель вычислительного графа

ONNX определяет переносимый, сериализованный формат вычислительного графа. Это не обязательно должна быть форма, которую фреймворк выбирает для внутреннего использования. Например, реализация может представлять модель в памяти иначе, если это более эффективно для манипуляций во время проходов оптимизации.

Реализация МОЖЕТ расширять ONNX, добавляя операторы, выражающие семантику, выходящую за рамки стандартного набора операторов, которые ДОЛЖНЫ поддерживаться всеми реализациями. Механизм для этого — добавление наборов операторов в свойство `opset_import` в модели, которая зависит от операторов расширения.

### Модели

Конструкцией верхнего уровня в ONNX является 'Модель', представленная в protocol buffers типом `onnx.ModelProto`

Основная цель структуры модели — связать метаданные с графом, который содержит все исполняемые элементы. Метаданные используются при первом чтении файла модели, предоставляя реализации информацию, необходимую для определения того, сможет ли она выполнить модель, генерировать сообщения журнала, отчеты об ошибках и т.д. Кроме того, метаданные полезны для инструментов, таких как IDE и галереи моделей, которым они нужны для информирования людей о назначении и характеристиках данной модели.

Каждая модель имеет следующие компоненты:

| Имя              | Тип                        | Описание                                                                                                                                    |
| ---------------- | -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| ir_version       | int64                      | Версия ONNX, предполагаемая моделью.                                                                                                        |
| opset_import     | OperatorSetId              | Коллекция идентификаторов наборов операторов, доступных модели. Реализация ДОЛЖНА поддерживать все операторы в наборе или отклонить модель. |
| producer_name    | string                     | Имя инструмента, использованного для генерации модели.                                                                                      |
| producer_version | string                     | Версия генерирующего инструмента.                                                                                                           |
| domain           | string                     | Обратное DNS-имя для указания пространства имен или домена модели, например, 'org.onnx'                                                     |
| model_version    | int64                      | Версия самой модели, закодированная в целое число.                                                                                          |
| doc_string       | string                     | Документация для этой модели, понятная человеку. Допускается использование Markdown.                                                        |
| graph            | Graph                      | Параметризованный граф, который вычисляется для выполнения модели.                                                                          |
| metadata_props   | map<string,string>         | Именованные значения метаданных; ключи должны быть уникальными.                                                                             |
| training_info    | TrainingInfoProto[]        | Необязательное расширение, содержащее информацию для обучения.                                                                              |
| functions        | FunctionProto[]            | Необязательный список функций, локальных для модели.                                                                                        |
| configuration    | DeviceConfigurationProto[] | (Версия IR >= 11) Необязательный список конфигураций нескольких устройств для распределенного выполнения.                                   |

Моделям СЛЕДУЕТ указывать домен и использовать обратные доменные имена на основе идентичности ответственной организации, то же соглашение, которое используется для [именования пакетов Java](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).

**Примечание: Исследование ONNX-файла**

Вы можете использовать инструмент `protoc`, являющийся частью дистрибутива Protocol Buffers, для изучения содержимого ONNX-файла следующим образом:

```bash
protoc --decode=onnx.ModelProto onnx.proto < yourfile.onnx
```

Где [onnx.proto](/onnx/onnx.proto) — это файл, являющийся частью данного репозитория.

Кроме того, вы можете использовать такой инструмент, как [Netron](https://github.com/lutzroeder/netron), для исследования ONNX-файла.

### Семантика модели

Семантика модели логического вывода — это _функция без состояния_ (за исключением, возможно, состояния, используемого для генерации случайных чисел). Таким образом, всякий раз, когда модель логического вывода (без операций с генератором случайных чисел) используется для выполнения логического вывода на тех же входных данных, ожидается, что она выдаст тот же результат.

Семантика обучающей модели — это _объект с состоянием_, причем состояние состоит из текущих значений обученных весов (и любого другого вспомогательного состояния, необходимого, например, импульса, используемого алгоритмом обучения). В частности, его семантика описывается тремя методами: метод инициализации (используемый для инициализации или сброса значений переменных состояния), метод шага обучения (для обучения с использованием пакета пар ввод-вывод) и метод логического вывода для выполнения вывода с использованием текущих значений обученных весов. Первые два метода обновляют состояние объекта, в то время как третий метод не имеет побочных эффектов.

### Необязательные метаданные

Поле 'metadata_props' в модели доступно для любых видов необязательных метаданных, которые инструмент или разработчик модели решат там разместить. Ниже перечислены определенные "стандартные" необязательные свойства метаданных модели.

| Имя           | Тип    | Формат                             | Описание                                                                |
| ------------- | ------ | ---------------------------------- | ----------------------------------------------------------------------- |
| model_author  | string | Список имен, разделенных запятыми. | Личное имя автора(ов) модели и/или их организаций.                      |
| model_license | string | Имя или URL.                       | Общеизвестное имя или URL лицензии, под которой предоставляется модель. |

### Идентификаторы набора операторов

Каждый набор операторов однозначно идентифицируется парой (домен, версия).

| Имя     | Тип    | Описание                                                                                      |
| ------- | ------ | --------------------------------------------------------------------------------------------- |
| domain  | string | Домен идентифицируемого набора операторов.                                                    |
| version | int64  | Версия идентифицируемого набора операторов. То же, что и 'opset_version' в наборе операторов. |

Версия набора операторов — это простое целое значение, которое монотонно увеличивается по мере публикации новых версий набора операторов.

Наборы операторов, отличные от набора по умолчанию, ДОЛЖНЫ указывать домен, и им СЛЕДУЕТ использовать обратные доменные имена на основе идентичности ответственной организации, то же соглашение, которое используется для [именования пакетов Java](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).

### Наборы операторов

Каждая модель ДОЛЖНА явно указывать наборы операторов, на которые она полагается для своей функциональности. Наборы операторов определяют доступные операторы и их версию. Каждая модель определяет импортированные наборы операторов по их доменам. Все модели неявно импортируют набор операторов ONNX по умолчанию.

Каждый набор операторов ДОЛЖЕН быть определен в отдельном документе, также использующем protobuf в качестве формата сериализации. Способ поиска документов набора операторов во время выполнения зависит от реализации.

**Примечание: На момент публикации этого документа ни одна известная реализация ONNX не обрабатывает документы набора операторов.**

Свойства набора операторов:

| Имя                   | Тип        | Описание                                                                                         |
| --------------------- | ---------- | ------------------------------------------------------------------------------------------------ |
| magic                 | string     | Значение 'ONNXOPSET'                                                                             |
| ir_version            | int32      | Версия ONNX, соответствующая операторам.                                                         |
| ir_version_prerelease | string     | Компонент предварительного выпуска SemVer IR.                                                    |
| ir_build_metadata     | string     | Метаданные сборки этой версии набора операторов.                                                 |
| domain                | string     | Домен набора операторов. Должен быть уникальным среди всех наборов.                              |
| opset_version         | int64      | Версия набора операторов.                                                                        |
| doc_string            | string     | Документация для этого набора операторов, понятная человеку. Допускается использование Markdown. |
| operator              | Operator[] | Операторы, содержащиеся в этом наборе операторов.                                                |

Версия набора операторов — это простое целое значение, которое монотонно увеличивается по мере публикации новых версий набора операторов.

Наборы операторов, отличные от набора по умолчанию, ДОЛЖНЫ указывать домен, и им СЛЕДУЕТ использовать обратные доменные имена на основе идентичности ответственной организации, то же соглашение, которое используется для [именования пакетов Java](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).

### Операторы

Каждый оператор, используемый в графе, ДОЛЖЕН быть явно объявлен одним из наборов операторов, импортированных моделью.

Свойства определения оператора:

| Имя           | Тип            | Описание                                                                                                                           |
| ------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| op_type       | string         | Имя оператора (чувствительное к регистру), используемое в узлах графа. ДОЛЖНО быть уникальным в пределах домена набора операторов. |
| since_version | int64          | Версия набора операторов, в которой этот оператор был представлен.                                                                 |
| status        | OperatorStatus | Одно из 'EXPERIMENTAL' или 'STABLE'.                                                                                               |
| doc_string    | string         | Строка документации для этого оператора, понятная человеку. Допускается использование Markdown.                                    |

Значение версии ДОЛЖНО совпадать со значением версии набора операторов, когда оператор был впервые опубликован. Последующие версии набора операторов НЕ ДОЛЖНЫ изменять сигнатуру или семантику оператора после его публикации как СТАБИЛЬНОГО (STABLE).

Свойство 'status' указывает, находится ли синтаксис, семантика или наличие оператора на экспериментальной или стабильной стадии. Как только оператор публикуется как СТАБИЛЬНЫЙ, его синтаксис и семантика НЕ ДОЛЖНЫ изменяться в последующих версиях набора операторов.

Существует два различных способа передачи информации операторам — входные данные и атрибуты. Входные данные представляют входные данные графа или значения, вычисленные в другом месте графа, в то время как атрибуты используются для значений, которые являются константами в графе. Это различие может быть очень важным для достижения хорошей производительности в некоторых реализациях и совершенно несущественным для других.

### Функции

_Функцию_ можно рассматривать как оператор, объединенный с реализацией этого оператора с использованием
других, более примитивных операций, называемых _телом функции_. Тело функции состоит из
топологически отсортированного списка узлов, которые образуют граф. Таким образом, функция сочетает в себе аспекты как
оператора, так и графа (описанного ниже).

Каждая функция, содержащаяся в Модели (также называемая локальной функцией модели), служит
реализацией соответствующего оператора по умолчанию или запасным вариантом. Однако среда выполнения
может выбрать использование альтернативной реализации оператора (обычно в виде оптимизированного ядра).
Таким образом, уникальное имя функции важно, поскольку оно неявно связано с
семантической спецификацией.

Сериализованная функция (_FunctionProto_) имеет следующие свойства:

| Имя             | Тип                | Описание                                                                                                                                                                                        |
| --------------- | ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name            | string             | Имя функции                                                                                                                                                                                     |
| domain          | string             | Домен, к которому принадлежит эта функция                                                                                                                                                       |
| overload        | string             | Часть уникального идентификатора функции (добавлено в версии IR 10)                                                                                                                             |
| doc_string      | string             | Документация для этой функции, понятная человеку. Допускается использование Markdown.                                                                                                           |
| attribute       | string[]           | Параметры-атрибуты функции                                                                                                                                                                      |
| attribute_proto | Attribute[]        | (Версия IR 9+) Параметры-атрибуты со значениями по умолчанию функции. Атрибут функции ДОЛЖЕН быть представлен либо как строковый атрибут, либо как атрибут (Attribute), но не оба одновременно. |
| input           | string[]           | Входные параметры функции                                                                                                                                                                       |
| output          | string[]           | Выходные параметры функции.                                                                                                                                                                     |
| node            | Node[]             | Список узлов, образующих частично упорядоченный вычислительный граф. Он должен быть в топологическом порядке.                                                                                   |
| opset_import    | OperatorSetId      | Коллекция идентификаторов наборов операторов, используемых реализацией функции.                                                                                                                 |
| value_info      | ValueInfo[]        | (Версия IR >= 10) Используется для хранения информации о типе и форме значений, используемых в функции.                                                                                         |
| metadata_props  | map<string,string> | (Версия IR >= 10) Именованные значения метаданных; ключи должны быть уникальными.                                                                                                               |

Имя и домен служат для уникальной идентификации оператора в версиях IR до 9. Версия IR 10 добавляет
поле overload, и тройка (имя, домен, перегрузка) действует как уникальный идентификатор для функций, хранящихся в
модели. Это предназначено для поддержки случаев, когда для различных вызовов функции в модели требуются различные тела функций.
Версия набора операторов явно не указывается в FunctionProto, но неявно определяется
версией набора операторов домена, включенного в модель.

Входные данные, выходные данные, атрибуты и attribute_proto (добавлено в версии IR 9) составляют часть сигнатуры оператора. Информация о типе
явно не включается в сигнатуру. Поле attribute_proto описывает параметры-атрибуты функции вместе с их значением по умолчанию (если не указано узлом вызова), в то время как поле attribute перечисляет параметры-атрибуты без значения по умолчанию. Имена в этих двух списках должны быть разными. Когда параметр-атрибут функции используется в узле внутри функции, он заменяется фактическим значением параметра, указанным для атрибута в узле вызова функции, если такой атрибут указан, и заменяется значением по умолчанию, если атрибут имеет указанное значение по умолчанию, и опускается в противном случае.

Поля opset_import и node описывают реализацию функции.

Поле value_info (добавлено в версии IR 10) позволяет модели хранить информацию о типе и форме значений, используемых в функции, включая ее входные и выходные данные. Обратите внимание, что это необязательно, и ONNX допускает полиморфизм функций.

### Графы

Граф используется для описания вычислений без побочных эффектов (функции).
Сериализованный граф состоит из набора полей метаданных, списка параметров модели и списка узлов вычислений.

Каждый вычислительный граф потоков данных структурирован как топологически отсортированный список узлов, которые образуют граф, и который НЕ ДОЛЖЕН содержать циклов. Каждый узел представляет вызов оператора или локальной функции модели. Каждый узел имеет ноль или более входов и один или более выходов.

Графы имеют следующие свойства:

| Имя            | Тип                | Описание                                                                                                                                                                                                                                                                         |
| -------------- | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name           | string             | Имя графа модели.                                                                                                                                                                                                                                                                |
| node           | Node[]             | Список узлов, образующих частично упорядоченный вычислительный граф на основе зависимостей входных/выходных данных. Он находится в топологическом порядке.                                                                                                                       |
| initializer    | Tensor[]           | Список именованных тензорных значений. Когда инициализатор имеет то же имя, что и вход графа, он определяет значение по умолчанию для этого входа. Когда инициализатор имеет имя, отличное от всех входов графа, он определяет постоянное значение. Порядок списка не определен. |
| doc_string     | string             | Документация для этой модели, понятная человеку. Допускается использование Markdown.                                                                                                                                                                                             |
| input          | ValueInfo[]        | Входные параметры графа, возможно инициализированные значением по умолчанию, найденным в 'initializer'.                                                                                                                                                                          |
| output         | ValueInfo[]        | Выходные параметры графа. Как только все выходные параметры были записаны при выполнении графа, выполнение завершается.                                                                                                                                                          |
| value_info     | ValueInfo[]        | Используется для хранения информации о типе и форме значений, которые не являются входами или выходами.                                                                                                                                                                          |
| metadata_props | map<string,string> | (Версия IR >= 10) Именованные значения метаданных; ключи должны быть уникальными.                                                                                                                                                                                                |

ValueInfo имеет следующие свойства:

| Имя        | Тип    | Описание                                                                                |
| ---------- | ------ | --------------------------------------------------------------------------------------- |
| name       | string | Имя значения/параметра.                                                                 |
| type       | Type   | Тип значения **включая информацию о форме**.                                            |
| doc_string | string | Документация для этого значения, понятная человеку. Допускается использование Markdown. |

Каждый основной (верхнего уровня) граф ДОЛЖЕН определять имена, типы и формы своих входов и выходов, которые задаются как структуры 'value info'. Для основных входов и выходов графа требуется иметь форму, указывающую ранг, даже если точные размерности не обязательно указывать.

Вложенные подграфы (заданные как значения атрибутов) ДОЛЖНЫ определять имена своих входов и выходов
и МОГУТ определять типы своих входов и выходов.

Каждый граф ДОЛЖЕН указывать имя.

Граф ДОЛЖЕН соответствовать правилу однократного присваивания (SSA) для всех выходов узлов; это означает, что все имена выходов узлов ДОЛЖНЫ быть уникальными в пределах графа.

Графы СЛЕДУЕТ заполнять строками документации, которые МОГУТ интерпретироваться с использованием синтаксиса разметки в стиле GitHub. HTML и другие языки разметки текста НЕ ДОЛЖНЫ использоваться в строках документации.

### Имена внутри графа

Все имена ДОЛЖНЫ соответствовать [правилам синтаксиса идентификаторов C90](https://en.cppreference.com/w/c/language/identifier).

Имена узлов, входов, выходов, инициализаторов и атрибутов организованы в несколько пространств имен. В пределах одного пространства имен каждое имя ДОЛЖНО быть уникальным для каждого данного графа. Пожалуйста, смотрите ниже для дальнейшего разъяснения в случае, когда граф содержит вложенные подграфы (как значения атрибутов).

Пространства имен:

| Пространство имен | Описание                                                                                                                                |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| Attribute         | Имена атрибутов оператора. Уникальны для каждого оператора.                                                                             |
| Value             | Имена значений — входов и выходов узлов, тензорных значений (если именованы), входов и выходов графа.                                   |
| Node              | Имена узлов графа.                                                                                                                      |
| Graph             | Имена графов в пределах домена, уникальные в пределах домена модели.                                                                    |
| Operator          | Имена операторов в пределах домена.                                                                                                     |
| Shape             | Имена переменных формы тензора — ограничены областью действия записей информации о значениях графа, где и встречаются переменные формы. |

### Узлы

Узлы вычислений состоят из имени, имени оператора, который они вызывают, списка именованных входов, списка именованных выходов и списка атрибутов.

Входы и выходы позиционно связаны с входами и выходами оператора. Атрибуты связаны с атрибутами оператора по имени.

Они имеют следующие свойства:

| Имя                   | Тип                            | Описание                                                                                                                                                                   |
| --------------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name                  | string                         | Необязательное имя узла, используемое только для диагностических целей.                                                                                                    |
| input                 | string[]                       | Имена значений, используемых узлом для передачи входных значений оператору узла. Они должны ссылаться либо на вход графа, либо на инициализатор графа, либо на выход узла. |
| output                | string[]                       | Имена выходов, используемых узлом для захвата данных от оператора, вызванного узлом. Они либо вводят значение в графе, либо ссылаются на выход графа.                      |
| op_type               | string                         | Символический идентификатор оператора для вызова.                                                                                                                          |
| domain                | string                         | Домен набора операторов, который содержит оператор с именем op_type.                                                                                                       |
| attribute             | Attribute[]                    | Именованные атрибуты, другая форма параметризации оператора, используемая для постоянных значений, а не для передаваемых значений.                                         |
| doc_string            | string                         | Документация для этого значения, понятная человеку. Допускается использование Markdown.                                                                                    |
| overload              | string                         | Часть уникального идентификатора функции (добавлено в версии IR 10)                                                                                                        |
| metadata_props        | map<string,string>             | (Версия IR >= 10) Именованные значения метаданных; ключи должны быть уникальными.                                                                                          |
| device_configurations | NodeDeviceConfigurationProto[] | (Версия IR >= 11) Конфигурации выполнения на нескольких устройствах для этого узла.                                                                                        |

Имя, принадлежащее пространству имен Value, может появляться в нескольких местах, а именно: как вход графа, инициализатор графа, выход графа, вход узла или выход узла. Появление имени как входа графа, инициализатора графа или выхода узла называется определением, а появление имени как входа узла или выхода графа называется использованием.

Имя значения, используемое в графе, должно иметь уникальное определение, за исключением того, что одно и то же имя МОЖЕТ появляться как в списке входов графа, так и в списке инициализаторов графа. (Дальнейшие исключения применяются при наличии вложенных подграфов, как описано ниже.)

Когда имя появляется как в списке инициализаторов, так и в списке входов графа, среда выполнения МОЖЕТ позволить вызывающему указать значение для этого (входного) имени, переопределяя значение, указанное в инициализаторе, и среда выполнения МОЖЕТ позволить пользователям опускать указание значения для этого (входного) имени, выбирая значение, указанное в инициализаторе. Имена констант, которые не предназначены для переопределения вызывающим, должны появляться только в списке инициализаторов, а не в списке входов графа. В моделях с версией IR >= 4, во вложенных подграфах, используемых как значения атрибутов, пользователи НЕ ДОЛЖНЫ использовать одно и то же имя как в качестве инициализатора подграфа, так и входа подграфа, если только спецификация соответствующего оператора явно не разрешает это. В моделях с версией IR <= 3 пользователи МОГУТ использовать одно и то же имя как в качестве инициализатора подграфа, так и входа подграфа, но это ограничено поддержкой констант через инициализаторы, которые не предназначены для соответствия каким-либо фактическим входам, передаваемым от узла в подграф. В частности, семантика оператора управления потоком определяет набор входов, поставляемых для выполнения подграфа, и эти имена входов НЕ ДОЛЖНЫ появляться как инициализаторы подграфа. Имена инициализаторов подграфа должны появляться в списке входов графа _после_ фактических входов. Это позволяет сопоставлять фактические и формальные входы позиционно.

Ребра в вычислительном графе устанавливаются, когда выходы одного узла упоминаются по имени во входах последующего узла.

Выходы данного узла вводят новые имена в граф. Значения выходов узла вычисляются оператором узла. Входы узла МОГУТ ссылаться на выходы узлов, входы графа и инициализаторы графа. Когда имя выхода узла совпадает с именем выхода графа, значение выхода графа является соответствующим выходным значением, вычисленным этим узлом. Вход узла во вложенном подграфе МОЖЕТ ссылаться на имена, введенные во внешних графах (как выходы узлов, входы графа или инициализаторы графа).

Граф ДОЛЖЕН использовать однократное присваивание для всех выходов узлов, что означает, что все имена выходов узлов ДОЛЖНЫ быть уникальными в пределах графа. В случае вложенного подграфа имена выходов узлов и имена входов и инициализаторов подграфа ДОЛЖНЫ отличаться от имен из внешних областей видимости, которые видны во вложенном подграфе. То есть затенение переменных не допускается.

Зависимости узлов НЕ ДОЛЖНЫ создавать циклы в вычислительном графе.

Количество входов и выходов в узле, их типы, набор атрибутов, указанных в узле, и их типы ДОЛЖНЫ удовлетворять ограничениям, налагаемым сигнатурой оператора узла.

Список узлов, определяющих вычислительный граф верхнего уровня, ДОЛЖЕН быть упорядочен топологически; то есть, если узел K следует за узлом N в графе, ни один из входов данных N не может ссылаться на выходы K.

Атрибуты узлов используются для передачи литеральных (статических) значений операторам.

#### Входные и выходные значения

Представление различает два вида значений: значения атрибутов, которые известны статически, и входные/выходные значения. Типы значений, разрешенных в этих двух случаях, различаются.

Входные и выходные значения находятся как входы, выходы и инициализаторы графа, а также как входы и выходы узлов. Их значения определяются во время выполнения либо кодом, который инициирует выполнение модели, либо операторами, вычисляющими выходные значения.

#### Атрибуты

Значения атрибутов находятся только в узлах, передаваемых операторам по ассоциации имени. Значения атрибутов являются константами времени выполнения в том смысле, что их значения определяются при построении графа модели и, следовательно, не вычисляются во время выполнения. Обычное использование атрибутов — представление коэффициентов, установленных во время обучения модели.

Атрибуты имеют следующие свойства:

| Имя           | Тип           | Описание                                                                                                    |
| ------------- | ------------- | ----------------------------------------------------------------------------------------------------------- |
| name          | string        | Имя атрибута. Должно быть уникальным среди атрибутов, входов и выходов для любого данного оператора и узла. |
| doc_string    | string        | Документация для этого значения, понятная человеку. Допускается использование Markdown.                     |
| type          | AttributeType | Тип атрибута, определяющий, какое из остальных полей используется для хранения значения атрибута.           |
| f             | float         | 32-битное значение с плавающей запятой.                                                                     |
| i             | int64         | 64-битное целое значение.                                                                                   |
| s             | byte[]        | Строка UTF-8.                                                                                               |
| t             | Tensor        | Тензорное значение.                                                                                         |
| g             | Graph         | Граф.                                                                                                       |
| floats        | float[]       | Список 32-битных значений с плавающей запятой.                                                              |
| ints          | int64[]       | Список 64-битных целых значений.                                                                            |
| strings       | byte[][]      | Список строк UTF-8.                                                                                         |
| tensors       | Tensor[]      | Список тензорных значений.                                                                                  |
| graphs        | Graph[]       | Список графов.                                                                                              |
| ref_attr_name | string        | Имя атрибута родительской функции.                                                                          |

Свойства 'name' и 'type' обязательны для всех атрибутов, и 'doc_string' СЛЕДУЕТ использовать для всех атрибутов. Атрибут ДОЛЖЕН иметь только одно из свойств, несущих значение.

В случае установки 'ref_attr_name' этот атрибут не содержит данных, а вместо этого является ссылкой на атрибут родительской функции с заданным именем. Может использоваться только внутри тела функции.

#### Вариативные входы и выходы

Последний вход или выход оператора МОЖЕТ быть помечен как вариативный. Например, оператор 'Max()' может использоваться для вычисления максимума переменного количества входных значений. Вариативный оператор имеет минимальную арность, которая определяет минимальное количество операндов, которые должны быть указаны.

Для каждого вариативного входа оператора должно быть указано N или более входов узла, где N — минимальная арность оператора. Для каждого вариативного выхода оператора должно быть указано N или более выходов узла, где N — минимальная арность оператора.

#### Необязательные входы и выходы

##### Статически необязательные

Некоторые операторы имеют входы, помеченные как необязательные, что означает, что ссылающийся узел МОЖЕТ не предоставлять значения для таких входов.

Некоторые операторы имеют необязательные выходы. Когда фактический выходной параметр оператора не указан, реализация оператора МОЖЕТ не вычислять значения для таких выходов.

Есть два способа оставить необязательный вход или выход неопределенным: первый, доступный только для завершающих входов и выходов, — просто не указывать этот вход или выход; второй метод — использовать пустую строку вместо имени входа или выхода.

Каждый узел, ссылающийся на оператор с необязательными выходами, ДОЛЖЕН предоставлять имя для каждого выхода, который вычисляется, и НЕ ДОЛЖЕН предоставлять имена для выходов, которые не вычисляются.

Необязательные входы и выходы вышеуказанного вида называются _статически-необязательными_.

##### Динамически необязательные (начиная с IR-8)

**Версия IR-8** ввела новый конструктор типов для представления _динамически-необязательных_ входов и выходов,
в дополнение к описанной выше статически-необязательной версии. Динамически-необязательный тензор INT64
является отдельным типом от обычного тензора INT64. В отличие от этого, статически-необязательный тензор INT64
не имеет отдельного типа; у него тот же тип, что и у тензора INT64.
Операторы `Optional` и `OptionalGetElement` ДОЛЖНЫ явно использоваться для преобразования между
динамически-необязательным типом и базовым необязательным типом.
Динамическая необязательность обеспечивает большую выразительность, чем статическая.

#### Внешние данные тензора

Необработанные данные для больших константных тензоров, таких как инициализаторы, МОГУТ быть сериализованы в отдельном файле. В таком случае тензор ДОЛЖЕН предоставить имя файла относительно файла модели и НЕ ДОЛЖЕН использовать поля значений. Он МОЖЕТ предоставить смещение в байтах и длину в этом файле. Он также МОЖЕТ указать дайджест SHA1 файла. Один файл МОЖЕТ содержать данные для нескольких тензоров.

Более подробную информацию можно найти в [Внешних данных](ExternalData.md).

## Стандартные типы данных

Существует два официальных варианта ONNX; основное различие между ними заключается в поддерживаемых типах и поддерживаемых операторах.

Что касается поддерживаемых типов, то и определение **ONNX**, и определение **ONNX-ML** признают тензоры, разреженные тензоры, последовательности, отображения и опциональные значения в качестве типов входов и выходов. Последовательности и отображения поддерживаются с версии IR 6 (релиз ONNX 1.6.0). Опциональный тип поддерживается с версии IR 8 (релиз ONNX 1.10.0).

Следующие типы данных поддерживаются ONNX для входов и выходов графов и узлов, а также для инициализаторов графа.

Примитивные числовые типы, строковые и булевы типы ДОЛЖНЫ использоваться как элементы тензоров.

### Определение тензора

Тензоры являются обобщением векторов и матриц; в то время как векторы имеют одно измерение, а матрицы — два, тензоры могут иметь любое количество измерений, включая ноль. Нульмерный тензор логически эквивалентен скалярному значению.

Математически тензор можно определить как пару последовательностей/списков (V, S), где S — форма тензора (список неотрицательных целых чисел), а V — список значений, длина которого равна произведению размерностей в S. Два тензора (V, S) и (V', S') равны тогда и только тогда, когда V = V' и S = S'. Длина S называется рангом.

- Если S имеет длину 0, V должно иметь длину 1, так как пустое произведение определено как 1. В этом случае тензор представляет скаляр.
- S может содержать размерности со значением 0. Если какие-либо размерности равны 0, V должно иметь длину 0.
- Если S имеет длину 1, V имеет длину, равную единственной размерности в S. В этом случае тензор представляет вектор.
- Тензор, представляющий вектор длины 1, имеет форму [1], в то время как тензор, представляющий скаляр, имеет форму []. Оба имеют один элемент, но скаляры _не являются_ векторами длины 1.

Форма S тензора — это список, но может быть представлена как тензор со значениями S и формой [R], где R — ранг тензора.

- Для тензора (V, S) тензор, представляющий его форму, равен (S, [R]).
- Форма скаляра — []. Представленная как тензор, [] имеет форму [0].

#### Представление

Обычно тензор представляют как вложенный список. Обычно это работает хорошо, но вызывает проблемы, когда задействованы нулевые размерности. Тензор формы (5, 0) может быть представлен как [[], [], [], [], []], но (0, 5) представляется как [], что теряет информацию о том, что второе измерение равно 5.

- Вложенный список не является полным представлением тензора с размерностями, равными нулю.

### Типы элементов тензора

| Группа                       | Типы                                                                                                      | Описание                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Типы с плавающей запятой     | float16, float32, float64, bfloat16, float8e4m3fn, float8e5m2, float8e4m3fnuz, float8e5m2fnuz, float4e2m1 | Значения, соответствующие стандартному представлению чисел с плавающей запятой IEEE 754-2008 или определенные в статьях [FP8 Formats for Deep Learning](https://arxiv.org/abs/2209.05433), [8-bit Numerical Formats for Deep Neural Networks](https://arxiv.org/abs/2206.02915) и спецификации [Open Compute Project](https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf) |
| Целочисленные типы со знаком | int2, int4, int8, int16, int32, int64                                                                     | Целые числа со знаком поддерживаются для разрядности 2-64 бита.                                                                                                                                                                                                                                                                                                                                              |
| Целочисленные типы без знака | uint2, uint4, uint8, uint16, uint32, uint64                                                               | Целые числа без знака поддерживаются для разрядности 2-64 бита.                                                                                                                                                                                                                                                                                                                                              |
| Комплексные типы             | complex64, complex128                                                                                     | Комплексное число с 32- или 64-битными действительной и мнимой частями.                                                                                                                                                                                                                                                                                                                                      |
| Другое                       | string                                                                                                    | Строки представляют текстовые данные. Все строки кодируются с использованием UTF-8.                                                                                                                                                                                                                                                                                                                          |
| Другое                       | bool                                                                                                      | Булевы значения представляют данные только с двумя значениями, обычно true и false.                                                                                                                                                                                                                                                                                                                          |

### Типы данных ввода/вывода

Следующие типы используются для определения типов входов и выходов графов и узлов.

| Вариант | Тип                | Описание                                                                                                                                                                                            |
| ------- | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ONNX    | плотные тензоры    | Представляет тензор. См. определение выше.                                                                                                                                                          |
| ONNX    | последовательность | Последовательности — это плотные, упорядоченные коллекции элементов однородных типов.                                                                                                               |
| ONNX    | отображение        | Отображения — это ассоциативные таблицы, определяемые типом ключа и типом значения.                                                                                                                 |
| ONNX    | опциональный       | Опциональные значения — это обертки, которые могут содержать элемент тензорного, последовательного или отображаемого типа или могут быть пустыми (не содержать ничего). [Подробности](ONNXTypes.md) |

#### Статические формы тензоров

В дополнение к типу элемента, типы тензоров имеют **статическую** форму. Статическая форма переменной-тензора связана с формой значения тензора во время выполнения (динамической), но отличается от нее. Статическая форма тензора — это список записей, который указывает, является ли тензор вектором, матрицей или многомерным значением. Например, матрица 100x100 имеет форму [100,100].

Статическая форма определяется 'TensorShapeProto':

```proto
message TensorShapeProto {
  message Dimension {
    oneof value {
      int64 dim_value = 1;
      string dim_param = 2;
    };
  };
  repeated Dimension dim = 1;
}
```

На которую ссылается сообщение о типе тензора:

```proto
  message Tensor {
    optional TensorProto.DataType elem_type = 1;
    optional TensorShapeProto shape = 2;
  }
```

Пустой список размеров, [], является допустимой формой тензора, обозначающей нульмерное (скалярное) значение. Нульмерный тензор отличается от тензора с неизвестной размерностью, который обозначается отсутствующим свойством 'shape' в сообщении Tensor. Когда свойство shape отсутствует в типе значения (включая вход узла),
это указывает на то, что соответствующее значение во время выполнения может иметь любую форму. В этом подразделе описывается, как интерпретировать отсутствие формы или форму с отсутствующими размерностями и т.д. Однако конкретные контексты использования могут налагать дополнительные ограничения на тип и форму.
Например, для входов и выходов модели (графа верхнего уровня) требуется _иметь_ форму, указывающую ранг входов и выходов,
даже если точные размерности не нужно указывать.

Каждый размер в списке МОЖЕТ быть выражен как целочисленное значение или как "переменная размерности" — строка, обозначающая, что фактический размер размерности статически не ограничен конкретным числом. Это полезно для объявления интерфейсов, которым важно количество измерений, но не точный размер каждого измерения. Размерность МОЖЕТ не иметь установленных ни dim_value, ни dim_param. Такая размерность представляет неизвестную размерность, не связанную с другими неизвестными размерностями.

Например, матрица NxM будет иметь список формы [N,M].

Имя каждой переменной размерности ДОЛЖНО соответствовать [правилам синтаксиса идентификаторов C90](https://en.cppreference.com/w/c/language/identifier).

В настоящее время переменные размерности не имеют области видимости. Переменная размерности "N" представляет одно и то же значение во всем графе модели. Например, если граф имеет два входа X и Y, каждый с формой ["N"], то во время выполнения значения, переданные для X и Y, ДОЛЖНЫ быть тензорами ранга 1 с одинаковой размерностью. Вложенные подграфы в настоящее время используют ту же область видимости для переменных размерности, что и основной граф. Это позволяет модели связывать размерности тензоров внутри подграфа с размерностями тензоров во внешнем графе.

ONNX поддерживает такие типы, как Последовательности Тензоров. Глобальная область видимости переменных размерности означает, что переменная с типом "Sequence<Tensor<float, [M,N]>" представляет последовательность тензоров, которые _все имеют одинаковую форму_. Переменные размерности M или N должны быть опущены в приведенном выше типе, если эта размерность не имеет фиксированного размера для всех тензоров в последовательности. Вся форма должна быть опущена в типе, если разные тензоры в последовательности могут иметь разные ранги.

Например, граф, выполняющий матричное перекрестное произведение, может быть определен как принимающий два входа формы [K,M] и [M,N] и выдающий выход формы [K,N].

Формы МОГУТ быть определены с использованием комбинации целых чисел и переменных.

_Исторические примечания_: Следующие расширения рассматривались на ранних этапах, но так и не были реализованы или поддержаны.

- Использование пустой строки (в качестве переменной размерности) для обозначения неизвестной размерности, не связанной ни с какой другой. От этого отказались в пользу использования Dimension, у которой не установлены ни dim_value, ни dim_param.
- Использование строки "\*" (в качестве переменной размерности) для обозначения последовательности из нуля или более размерностей неизвестной мощности. Это не поддерживается. В текущей реализации количество измерений в форме ДОЛЖНО представлять ранг тензора. Тензор неизвестного ранга представляется с помощью объекта TypeProto::Tensor без формы, что разрешено.
- Механизм области видимости, позволяющий использовать переменные размерности, локальные для подграфа (например, тела цикла), может быть полезен, но в настоящее время не поддерживается.
- ONNX поддерживает такие типы, как Последовательности Тензоров. Механизм области видимости для переменных размерности, локальных для типа, может быть полезен для различения следующих двух типов: последовательность квадратных матриц (разного размера) и последовательность квадратных матриц (все одного размера). В настоящее время это не поддерживается.

### Типы атрибутов

Система типов, используемая для атрибутов, связана с системой типов входов и выходов, но немного отличается от нее. Значения атрибутов могут быть плотным тензором, разреженным тензором, скалярным числовым значением, строкой, графом или повторяющимися значениями одного из вышеупомянутых типов.

## Другие метаданные

Структура ModelProto, а в версиях IR >= 10 и различные другие структуры (GraphProto, FunctionProto, NodeProto)
содержат поле metadata_props, позволяющее пользователям хранить другие метаданные в виде пар ключ-значение.
Рекомендуется, чтобы пользователи использовали имена ключей с префиксом в виде обратного DNS-имени
(например, "ai.onnxruntime.key1"), чтобы избежать конфликтов между различными использованиями.
Неполные имена могут использоваться в будущем стандартом ONNX.

## Информация, связанная с обучением

Информация, связанная с обучением, описывается одним или несколькими экземплярами _TrainingInfoProto_, содержащимися в модели. Каждый TrainingInfoProto содержит информацию, описывающую как шаг инициализации, так и шаг обучения.

Шаг инициализации описывается с использованием графа (TrainingInfoProto.initialization) и карты привязки инициализации (TrainingInfoProto.initialization*binding). Шаг инициализации выполняется путем вычисления графа и присвоения выходных данных, созданных графом, *переменным состояния\_ обучающей модели, как указано в привязке инициализации. Привязка инициализации концептуально является картой, заданной как список пар ключ-значение, где каждый ключ является именем переменной состояния, а значение является именем выхода (инициализационного) графа. Каждое имя, указанное как ключ в привязке, ДОЛЖНО быть именем инициализатора, который появляется в основном графе логического вывода (т.е., в ModelProto.graph.initializer) или именем инициализатора, который появляется в TrainingInfoProto.algorithm.initializer. Каждое имя, указанное как значение в привязке, ДОЛЖНО быть именем выхода графа TrainingInfoProto.initialization. Значения ключей, указанные в повторяющемся поле initialization_binding, ДОЛЖНЫ быть уникальными.

Шаг обучения аналогично описывается с использованием графа (TrainingInfoProto.algorithm) и карты привязки обновления (TrainingInfoProto.update_binding). Шаг обучения выполняется путем вычисления графа и присвоения выходных данных, созданных графом, переменным состояния, как указано в привязке обновления. Ограничения и описание, представленные выше для инициализации, применимы и к шагу обучения.

Таким образом, переменные состояния обучающей модели состоят из подмножества инициализаторов основного графа логического вывода (т.е., ModelProto.graph.initializer) и графа алгоритма обучения (TrainingInfoProto.algorithm.initializer), идентифицированных ключами привязок (в TrainingInfoProto.initialization_binding и TrainingInfoProto.update_binding). Обратите внимание, что переменные состояния не являются постоянными значениями в контексте обучения. Они представляют изменяемые переменные, общие для нескольких графов (неявно объявленные в области видимости обучающей модели верхнего уровня). Это неявное объявление общих изменяемых переменных используется вместо явного объявления для целей обратной совместимости с представлением графа логического вывода.

Все переменные состояния предварительно инициализируются значением, указанным в соответствующем инициализаторе. Последующий вызов для выполнения шага инициализации (с использованием соответствующего API, предоставляемого средой выполнения) обновляет значения переменных состояния, как описано выше. Если обучающая модель имеет более одного экземпляра TrainingInfoProto, шаг инициализации, соответствующий каждому из них, выполняется по порядку. TrainingInfoProto.initialization МОЖЕТ быть опущен (только если нет initialization_bindings). Для шага обучения среда выполнения МОЖЕТ позволить пользователям вызывать любой из TrainingInfoProto.algorithm, позволяя процессу обучения чередовать различные алгоритмы по желанию. Порядок, в котором вызываются различные TrainingProto.algorithms, влияет на результат обучения, и вызывающий несет ответственность за вызов их в правильном порядке.

## Многод evice конфигурация (Версия IR >= 11)

ONNX поддерживает выполнение на нескольких устройствах с помощью спецификаций конфигурации устройств, которые обеспечивают распределенный логический вывод и обучение. Это включает поддержку тензорного параллелизма (разделение тензоров между несколькими устройствами) и конвейерного параллелизма (распределение различных подграфов по разным устройствам).

### Конфигурации устройств

Модель МОЖЕТ указывать одну или несколько конфигураций нескольких устройств с помощью _DeviceConfigurationProto_, содержащихся в модели. Каждая конфигурация описывает конкретное расположение устройств, которое может использоваться для выполнения модели.

Свойства конфигурации устройства:

| Имя         | Тип      | Описание                                                                                     |
| ----------- | -------- | -------------------------------------------------------------------------------------------- |
| name        | string   | Имя конфигурации. Это поле ДОЛЖНО присутствовать для этой версии IR.                         |
| num_devices | int32    | Количество устройств в этой конфигурации. Это поле ДОЛЖНО присутствовать для этой версии IR. |
| device      | string[] | Необязательные имена устройств. Если указаны, ДОЛЖНЫ иметь длину num_devices.                |

### Конфигурация устройства узла

Отдельные узлы могут указывать специфическую для устройства информацию о выполнении с помощью _NodeDeviceConfigurationProto_. Это позволяет детально контролировать, как вычисления распределяются между устройствами.

Свойства конфигурации устройства узла:

| Имя              | Тип                 | Описание                                                                                                                   |
| ---------------- | ------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| configuration_id | string              | ID конфигурации. ДОЛЖЕН соответствовать имени DeviceConfigurationProto. Это поле ДОЛЖНО присутствовать для этой версии IR. |
| sharding_spec    | ShardingSpecProto[] | Спецификации шардинга для входов и выходов узла.                                                                           |
| pipeline_stage   | int32               | Необязательный идентификатор этапа конвейера для этого узла.                                                               |

### Спецификация шардинга

Шардинг описывает, как тензоры разделяются или реплицируются между несколькими устройствами. _ShardingSpecProto_ определяет поведение шардинга для конкретного входного или выходного тензора узла.

Свойства спецификации шардинга:

| Имя                       | Тип                    | Описание                                                                                                                                                                           |
| ------------------------- | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tensor_name               | string                 | Идентифицирует входной или выходной тензор, который шардируется. Должен соответствовать имени в списке входов или выходов узла. Это поле ДОЛЖНО присутствовать для этой версии IR. |
| device                    | int64[]                | Список устройств, между которыми тензор шардируется или на которых реплицируется.                                                                                                  |
| index_to_device_group_map | IntIntListEntryProto[] | Необязательное отображение, указывающее группы устройств, когда идентификатор устройства представляет несколько физических устройств.                                              |
| sharded_dim               | ShardedDimProto[]      | Спецификация шардинга для каждой оси тензора.                                                                                                                                      |

### Шардированная размерность

_ShardedDimProto_ описывает, как одна ось тензора шардируется между устройствами.

Свойства шардированной размерности:

| Имя             | Тип                     | Описание                                                                                                                                      |
| --------------- | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| axis            | int64                   | Ось тензора, которая шардируется. Должна быть в диапазоне [-r, r-1], где r — ранг тензора. Это поле ДОЛЖНО присутствовать для этой версии IR. |
| simple_sharding | SimpleShardedDimProto[] | Описывает, как ось делится на шарды.                                                                                                          |

### Простая шардированная размерность

_SimpleShardedDimProto_ указывает, что N блоков делятся на M шардов, где N может быть символическим, но M должно быть постоянным.

Свойства простой шардированной размерности:

| Имя        | Тип    | Описание                                                                                                      |
| ---------- | ------ | ------------------------------------------------------------------------------------------------------------- |
| dim_value  | int64  | Значение размерности, которое нужно шардировать (альтернатива dim_param).                                     |
| dim_param  | string | Символический параметр размерности, который нужно шардировать (альтернатива dim_value).                       |
| num_shards | int64  | Количество шардов, на которые нужно разделить размерность. Это поле ДОЛЖНО присутствовать для этой версии IR. |

### Семантика выполнения на нескольких устройствах

Аннотации для нескольких устройств являются подсказками для внутренних компонентов выполнения и не влияют на вычислительную семантику модели. Внутренние компоненты МОГУТ игнорировать эти аннотации, если указанные конфигурации не поддерживаются или недоступны. Все операции связи, необходимые для выполнения на нескольких устройствах (такие как передача данных между устройствами), являются неявными и обрабатываются средой выполнения.

Для тензорного параллелизма тензоры могут быть:

- **Разделены** между устройствами по указанным осям, распределяя различные части данных по разным устройствам
- **Реплицированы** между устройствами, когда одни и те же данные тензора дублируются на нескольких устройствах

Конвейерный параллелизм указывается с помощью необязательных идентификаторов этапов конвейера, которые предполагают, как распределить подграфы между устройствами для конвейерного выполнения.

Для получения более подробной информации о шаблонах выполнения на нескольких устройствах и примерах см. [Предложение по нескольким устройствам](proposals/ONNXMultiDeviceProposal.md).

## Другие документы спецификации

Спецификация ONNX состоит из этого документа, который определяет семантику IR и стандартные типы данных, и следующих документов, определяющих семантику стандартных операторов и синтаксис IR. Последний задается в виде схем Protobuf v2 и v3.

Смотрите [документацию по категории метаданных](MetadataProps.md) для более подробной информации.

### Операторы

[Операторы нейронных сетей](Operators.md)

[Операторы классического машинного обучения](Operators-ml.md)

### Синтаксис

[Модели и графы ONNX - protobuf v2](../onnx/onnx.proto)

[Модели и графы ONNX - protobuf v3](../onnx/onnx.proto3)

[Модели и графы ONNX-ML - protobuf v2](../onnx/onnx-ml.proto)

[Модели и графы ONNX-ML - protobuf v3](../onnx/onnx-ml.proto3)

[Наборы операторов ONNX - protobuf v2](../onnx/onnx-operators.proto)

[Наборы операторов ONNX - protobuf v3](../onnx/onnx-operators.proto3)

[Наборы операторов ONNX-ML - protobuf v2](../onnx/onnx-operators-ml.proto)

[Наборы операторов ONNX-ML - protobuf v3](../onnx/onnx-operators-ml.proto3)

### Соглашения о версионировании и лучшие практики

[Версионирование](Versioning.md)
